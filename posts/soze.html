<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><meta name="theme-color" content="#383838"/><meta name="description" content="Me!"/><title>Söze | Lucas Pickering</title><meta name="next-head-count" content="5"/><link rel="preload" href="/_next/static/css/5aa0192adee9681ad795.css" as="style"/><link rel="stylesheet" href="/_next/static/css/5aa0192adee9681ad795.css" data-n-g=""/><link rel="preload" href="/_next/static/css/eb4f9c0737434c1b79d7.css" as="style"/><link rel="stylesheet" href="/_next/static/css/eb4f9c0737434c1b79d7.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-a54b4f32bdc1ef890ddd.js"></script><script src="/_next/static/chunks/webpack-0e0f5c5c9fa5a29e0d78.js" defer=""></script><script src="/_next/static/chunks/framework-895f067827ebe11ffe45.js" defer=""></script><script src="/_next/static/chunks/main-b9780dc6f4fa7abb3771.js" defer=""></script><script src="/_next/static/chunks/pages/_app-f6ece5aada8f1cfaf76f.js" defer=""></script><script src="/_next/static/chunks/544-ee28b110819265c2926a.js" defer=""></script><script src="/_next/static/chunks/513-d2ad5a67844e54e116c9.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bslug%5D-9f0e16c9123f07ecf097.js" defer=""></script><script src="/_next/static/T5bb572TaGINccnbdwMiP/_buildManifest.js" defer=""></script><script src="/_next/static/T5bb572TaGINccnbdwMiP/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="PageContainer_contentWrapper__3Bc1C"><header class="NavHeader_navHeader__2wb8k"><nav class="NavHeader_navBar__1Dijy"><div class="NavHeader_titleLinkWrapper__3UzkA"><a class="NavHeader_titleLink__2BFBI" href="/">A Thought</a><p class="NavHeader_caption__2ehiM">(All I could muster)</p></div><div class="NavHeader_otherLinks__27YNZ"><a href="/projects">Projects</a><a href="/photos">Photos</a><a href="/about">About</a><a href="https://github.com/LucasPickering">GitHub</a></div></nav></header><main class="PageContainer_mainContent__2VeJN"><article><div class="PostView_postHeader__183v-"><h1>Söze</h1><span class="PostView_postDate__w6r5-">Nov 29, 2020</span></div><div class="PostView_postLinks__3B9dI"><a href="https://github.com/LucasPickering/soze">Code</a></div><img class="PostView_banner__HGY8M" src="/assets/soze/banner.png"/><div><div><h2>Background</h2>
<p>A long time ago (circa 2013), I decided I wanted to mod my PC. Fortunately, my case (the <a href="https://www.bitfenix.com/products/chassis/mini-itx/prodigy/">BitFenix Prodigy</a>) is very amenable to that kind of thing, so I had a lot of options. Over the years, I added stuff, took it away, changed it, turned it upside, and eventually ended up with what I have today: an RGB LED strip, and a character LCD mounted to the front.</p>
<p><img src="/assets/soze/pc.jpg" alt="The computer, in all its glory"/><span class="Image_caption__3mmiI">The computer, in all its glory</span></p>
<h2>The Hardware</h2>
<p>The hardware involved in this obviously includes the LEDs and an LCD, as well as a few other pieces that make it possible to control everything from software.</p>
<h3>Raspberry Pi Zero</h3>
<p><a href="https://www.raspberrypi.org/products/raspberry-pi-zero-w/">Raspberry Pi Zero W</a> | <a href="https://www.adafruit.com/product/2348">Adafruit motor HAT</a></p>
<p>The RPi serves as the brains of the operation. It, along with the Motor HAT expansion board, controls the LEDs and the LCD. It also connects to the computer&#x27;s power supply to determine when the PC turns on and off (which is used in the software to shift between &quot;day&quot; and &quot;night&quot; mode).</p>
<p><img src="/assets/soze/rpi.jpg" alt="The Motor HAT on top with the Raspberry Pi visible underneath it"/><span class="Image_caption__3mmiI">The Motor HAT on top with the Raspberry Pi visible underneath it</span></p>
<p>The RPi connects to the PC&#x27;s motherboard via USB for power, and uses WiFi for network access. But since my PC case is basically a Faraday cage, sometimes the WiFi isn&#x27;t strong enough and I have to fall back to using the USB as a network interface as well. Generally though, the WiFi is good enough. If you&#x27;re curious, check out the README for <a href="https://github.com/LucasPickering/soze#pin-layout">a detailed layout</a> of all the pins being used on the RPi.</p>
<p><img src="/assets/soze/usb.jpg" alt="The USB cable where it connects to the PC motherboard"/><span class="Image_caption__3mmiI">The USB cable where it connects to the PC motherboard</span></p>
<h3>LEDs</h3>
<p><a href="https://www.adafruit.com/product/346">RGB LED strip</a></p>
<p>A simple RGB LED strip. Each component (red/green/blue) is controlled by PWM from a motor controller. This strip can display pretty much any color, but the catch is that the LEDs all show the same color at once. But still, RGB makes your computer faster (as proven by Science™), so this piece is critical. Similarly, I&#x27;m currently investigating the effects of flame decals on CPU performance. Early results are promising.</p>
<p><img src="/assets/soze/leds.jpg" alt="The LED strip routed around the top of the PC"/><span class="Image_caption__3mmiI">The LED strip routed around the top of the PC</span></p>
<p>This LED strip has gone through a few iterations, including pure analog control (which involved a homemade heatsink to prevent the whole thing from catching fire) and being driven by an Arduino Uno. This current iteration, with the Raspberry Pi and the motor controller, is definitely the cleanest and most configurable of all though. Having a full blown OS in control means the software can be a lot more complex and can provide a web UI (see <a href="#ui">UI</a>).</p>
<h3>LCD</h3>
<p><a href="https://www.adafruit.com/product/498">RGB backlight LCD</a> | <a href="https://www.adafruit.com/product/781">LCD backpack</a></p>
<p>This is the more complicated half of the mods. I mounted a 20x4 character LCD onto the front of my PC (in the space intended for a 5.25&quot; CD drive). The LCD supports loading custom characters, which means I was able to define characters that form pieces of <em>bigger</em> characters, which means... big numbers! Wow, computers!</p>
<p><img src="/assets/soze/lcd_front.jpg" alt="The front of the LCD"/><span class="Image_caption__3mmiI">The front of the LCD</span></p>
<p>I initially drove this with an Arduino Uno wired directly to the LCD, but then I switched over to the Raspberry Pi and discovered Adafruit&#x27;s LCD backpack, which cuts a 16-pin wiring operation down to a 3-pin UART connection. It also greatly simplifies the software logic to a basic serial protocol, which makes controlling screen content/color/etc. much easier.</p>
<p><img src="/assets/soze/lcd_back.jpg" alt="The back side of the LCD (the larger green board) with the backpack (the smaller blue board)"/><span class="Image_caption__3mmiI">The back side of the LCD (the larger green board) with the backpack (the smaller blue board)</span></p>
<h2>The Software</h2>
<p>If the RPi is the brain, then the software is the... braincode? I don&#x27;t know, this metaphor is breaking down. Software do what software do, it tells the RPi how to function. Each of these four components is a separate body of code, and they all communicate with each other over the network. Here&#x27;s a synopsis of all the pieces. Basically, the UI talks to the API over HTTP (like and normal web app), then within the server, everything uses Redis as an intermediary.</p>
<p><img src="/assets/soze/diagram.png" alt="A diagram of the software components"/><span class="Image_caption__3mmiI">A diagram of the software components</span></p>
<p>Redis is great for this application because it&#x27;s fast, lightweight, handles all the annoying parts of networking, and the pub/sub model makes it easy to notify the other components when something changes. It also provides some basic persistence, which is easier to use than dumping settings to a JSON file and reloading them on startup.</p>
<h3>UI</h3>
<p>Everyone loves web development, right? This is a pretty simple UI built in TypeScript with React. It gives you full control of the LEDs and the LCD. It&#x27;s hosted directly of the RPi, which makes deployment easy, but unfortunately means it&#x27;s only accessible on the LAN. To make it accessible anywhere on the Internet, I&#x27;d have to set up a VPN to the RPi, host the UI elsewhere, and figure out auth. That sounds like a lot of work, and why would I want to control the PC while I&#x27;m not home anyway?</p>
<p><img src="/assets/soze/ui.png" alt="The Söze web UI"/><span class="Image_caption__3mmiI">The Söze web UI</span></p>
<h3>API</h3>
<p>This is a pretty thin layer that provides read/write access to the user&#x27;s settings via HTTP. It uses Python+Flask. It doesn&#x27;t involve any auth/permissions/etc., so very simple. For reads, this just reads a JSON string from Redis and returns it to the user. For writes, it basically validates JSON then dumps it into Redis.</p>
<h3>Reducer</h3>
<p>So if the RPi is the brain and the software is the braincode, then the reducer is the brain&#x27;s Supreme Metatarsal Cortex (or something like that). Basically, this is the chunk of the code that takes the users settings and constantly calculates what each bit of hardware should be doing. Periodically (e.g. every 10ms), it recalculates the current LED color, and the current LCD text and color, then sends that data to the display.</p>
<p>This communicates in both directions via Redis. It reads user settings from Redis, calculates derived state, then writes that back to different keys in Redis.</p>
<p>The whole system is designed in order to offload all the difficult logic into the reducer. By putting all the complicated stuff in one place, it makes it easy to add and change functionality. And in most cases, changes here require minimal to no corresponding changes in the API/display, because the Redis contracts are decided to be as unrestrictive as possible.</p>
<h3>Display</h3>
<p>The display is a minimal adapter between the reducer and the actual hardware. The reducer produces an RGB color for the LEDs and a stream of binary commands for the LCD, so all the display has to do is take that data from Redis and forward out over the appropriate hardware channels. It might seem like this job doesn&#x27;t justify having a completely separate service, but there&#x27;s a big upside to it: mocking.</p>
<p>When developing and running this on my desktop/laptop, obviously the expected hardware isn&#x27;t present. After experimenting with a few other mocking mechanisms at first, I found this was the easiest way to do mocking. There is an alternative display that doesn&#x27;t attempt to interact with hardware at all, and instead just mimics the LED and LCD state in a terminal window. This makes it easy to spin up 90% of the stack exactly how it would exist on the RPi, and minimize the amount of code that has to be mocked.</p>
<h2>In Conclusion</h2>
<p>So that&#x27;s like... everything. Hope it was interesting? All the code is <a href="https://github.com/LucasPickering/soze">on GitHub</a> (the hardware is not). It&#x27;s taken many years of tweaking but I&#x27;m very happy with where this setup is now. I&#x27;m sure I&#x27;ll continue to work on it in the future (currently I&#x27;m working on porting chunks of the software to Rust for fun), so it&#x27;s only going to get better.</p></div></div></article></main><footer class="PageContainer_footer__2pitm"><span>Copyright 2021 Lucas Pickering</span><a href="/">Recursion!</a></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"metadata":{"title":"Söze","date":"2020-11-29T00:00:00.000Z","summary":"Hardware mods for my PC, with a suite of software services to make it all run smoothly. The mods include an LCD mounted on the front and a strip of RGB LEDs inside, all driven by a Raspberry Pi Zero.","banner":"/assets/soze/banner.png","links":{"Code":"https://github.com/LucasPickering/soze"},"tags":["post","project","python","typescript","hardware"]},"slug":"soze","markdown":"\n## Background\n\nA long time ago (circa 2013), I decided I wanted to mod my PC. Fortunately, my case (the [BitFenix Prodigy](https://www.bitfenix.com/products/chassis/mini-itx/prodigy/)) is very amenable to that kind of thing, so I had a lot of options. Over the years, I added stuff, took it away, changed it, turned it upside, and eventually ended up with what I have today: an RGB LED strip, and a character LCD mounted to the front.\n\n![The computer, in all its glory](/assets/soze/pc.jpg)\n\n## The Hardware\n\nThe hardware involved in this obviously includes the LEDs and an LCD, as well as a few other pieces that make it possible to control everything from software.\n\n### Raspberry Pi Zero\n\n[Raspberry Pi Zero W](https://www.raspberrypi.org/products/raspberry-pi-zero-w/) | [Adafruit motor HAT](https://www.adafruit.com/product/2348)\n\nThe RPi serves as the brains of the operation. It, along with the Motor HAT expansion board, controls the LEDs and the LCD. It also connects to the computer's power supply to determine when the PC turns on and off (which is used in the software to shift between \"day\" and \"night\" mode).\n\n![The Motor HAT on top with the Raspberry Pi visible underneath it](/assets/soze/rpi.jpg)\n\nThe RPi connects to the PC's motherboard via USB for power, and uses WiFi for network access. But since my PC case is basically a Faraday cage, sometimes the WiFi isn't strong enough and I have to fall back to using the USB as a network interface as well. Generally though, the WiFi is good enough. If you're curious, check out the README for [a detailed layout](https://github.com/LucasPickering/soze#pin-layout) of all the pins being used on the RPi.\n\n![The USB cable where it connects to the PC motherboard](/assets/soze/usb.jpg)\n\n### LEDs\n\n[RGB LED strip](https://www.adafruit.com/product/346)\n\nA simple RGB LED strip. Each component (red/green/blue) is controlled by PWM from a motor controller. This strip can display pretty much any color, but the catch is that the LEDs all show the same color at once. But still, RGB makes your computer faster (as proven by Science™), so this piece is critical. Similarly, I'm currently investigating the effects of flame decals on CPU performance. Early results are promising.\n\n![The LED strip routed around the top of the PC](/assets/soze/leds.jpg)\n\nThis LED strip has gone through a few iterations, including pure analog control (which involved a homemade heatsink to prevent the whole thing from catching fire) and being driven by an Arduino Uno. This current iteration, with the Raspberry Pi and the motor controller, is definitely the cleanest and most configurable of all though. Having a full blown OS in control means the software can be a lot more complex and can provide a web UI (see [UI](#ui)).\n\n### LCD\n\n[RGB backlight LCD](https://www.adafruit.com/product/498) | [LCD backpack](https://www.adafruit.com/product/781)\n\nThis is the more complicated half of the mods. I mounted a 20x4 character LCD onto the front of my PC (in the space intended for a 5.25\" CD drive). The LCD supports loading custom characters, which means I was able to define characters that form pieces of _bigger_ characters, which means... big numbers! Wow, computers!\n\n![The front of the LCD](/assets/soze/lcd_front.jpg)\n\nI initially drove this with an Arduino Uno wired directly to the LCD, but then I switched over to the Raspberry Pi and discovered Adafruit's LCD backpack, which cuts a 16-pin wiring operation down to a 3-pin UART connection. It also greatly simplifies the software logic to a basic serial protocol, which makes controlling screen content/color/etc. much easier.\n\n![The back side of the LCD (the larger green board) with the backpack (the smaller blue board)](/assets/soze/lcd_back.jpg)\n\n## The Software\n\nIf the RPi is the brain, then the software is the... braincode? I don't know, this metaphor is breaking down. Software do what software do, it tells the RPi how to function. Each of these four components is a separate body of code, and they all communicate with each other over the network. Here's a synopsis of all the pieces. Basically, the UI talks to the API over HTTP (like and normal web app), then within the server, everything uses Redis as an intermediary.\n\n![A diagram of the software components](/assets/soze/diagram.png)\n\nRedis is great for this application because it's fast, lightweight, handles all the annoying parts of networking, and the pub/sub model makes it easy to notify the other components when something changes. It also provides some basic persistence, which is easier to use than dumping settings to a JSON file and reloading them on startup.\n\n### UI\n\nEveryone loves web development, right? This is a pretty simple UI built in TypeScript with React. It gives you full control of the LEDs and the LCD. It's hosted directly of the RPi, which makes deployment easy, but unfortunately means it's only accessible on the LAN. To make it accessible anywhere on the Internet, I'd have to set up a VPN to the RPi, host the UI elsewhere, and figure out auth. That sounds like a lot of work, and why would I want to control the PC while I'm not home anyway?\n\n![The Söze web UI](/assets/soze/ui.png)\n\n### API\n\nThis is a pretty thin layer that provides read/write access to the user's settings via HTTP. It uses Python+Flask. It doesn't involve any auth/permissions/etc., so very simple. For reads, this just reads a JSON string from Redis and returns it to the user. For writes, it basically validates JSON then dumps it into Redis.\n\n### Reducer\n\nSo if the RPi is the brain and the software is the braincode, then the reducer is the brain's Supreme Metatarsal Cortex (or something like that). Basically, this is the chunk of the code that takes the users settings and constantly calculates what each bit of hardware should be doing. Periodically (e.g. every 10ms), it recalculates the current LED color, and the current LCD text and color, then sends that data to the display.\n\nThis communicates in both directions via Redis. It reads user settings from Redis, calculates derived state, then writes that back to different keys in Redis.\n\nThe whole system is designed in order to offload all the difficult logic into the reducer. By putting all the complicated stuff in one place, it makes it easy to add and change functionality. And in most cases, changes here require minimal to no corresponding changes in the API/display, because the Redis contracts are decided to be as unrestrictive as possible.\n\n### Display\n\nThe display is a minimal adapter between the reducer and the actual hardware. The reducer produces an RGB color for the LEDs and a stream of binary commands for the LCD, so all the display has to do is take that data from Redis and forward out over the appropriate hardware channels. It might seem like this job doesn't justify having a completely separate service, but there's a big upside to it: mocking.\n\nWhen developing and running this on my desktop/laptop, obviously the expected hardware isn't present. After experimenting with a few other mocking mechanisms at first, I found this was the easiest way to do mocking. There is an alternative display that doesn't attempt to interact with hardware at all, and instead just mimics the LED and LCD state in a terminal window. This makes it easy to spin up 90% of the stack exactly how it would exist on the RPi, and minimize the amount of code that has to be mocked.\n\n## In Conclusion\n\nSo that's like... everything. Hope it was interesting? All the code is [on GitHub](https://github.com/LucasPickering/soze) (the hardware is not). It's taken many years of tweaking but I'm very happy with where this setup is now. I'm sure I'll continue to work on it in the future (currently I'm working on porting chunks of the software to Rust for fun), so it's only going to get better.\n"},"_superjson":{"values":{"post.metadata.date":["Date"]}}},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"soze"},"buildId":"T5bb572TaGINccnbdwMiP","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>