<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><meta name="theme-color" content="#383838"/><meta name="description" content="Me!"/><title>Terra | Lucas Pickering</title><meta name="next-head-count" content="5"/><link rel="preload" href="/_next/static/css/5aa0192adee9681ad795.css" as="style"/><link rel="stylesheet" href="/_next/static/css/5aa0192adee9681ad795.css" data-n-g=""/><link rel="preload" href="/_next/static/css/ab9503f5c7765602f425.css" as="style"/><link rel="stylesheet" href="/_next/static/css/ab9503f5c7765602f425.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-a54b4f32bdc1ef890ddd.js"></script><script src="/_next/static/chunks/webpack-0e0f5c5c9fa5a29e0d78.js" defer=""></script><script src="/_next/static/chunks/framework-2191d16384373197bc0a.js" defer=""></script><script src="/_next/static/chunks/main-b9780dc6f4fa7abb3771.js" defer=""></script><script src="/_next/static/chunks/pages/_app-a550731b422d1a6199e4.js" defer=""></script><script src="/_next/static/chunks/pages/posts/terra-e39c18b0cf969022f9bf.js" defer=""></script><script src="/_next/static/GOjKSWOk6q0aODtCvQMHr/_buildManifest.js" defer=""></script><script src="/_next/static/GOjKSWOk6q0aODtCvQMHr/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="PageContainer_contentWrapper__3Bc1C"><header class="NavHeader_navHeader__2wb8k"><nav class="NavHeader_navBar__1Dijy"><div class="NavHeader_titleLinkWrapper__3UzkA"><a class="NavHeader_titleLink__2BFBI" href="/">A Thought</a><p class="NavHeader_caption__2ehiM">(All I could muster)</p></div><div class="NavHeader_otherLinks__27YNZ"><a href="/projects">Projects</a><a href="/photos">Photos</a><a href="/about">About</a><a href="https://github.com/LucasPickering">GitHub</a></div></nav></header><main class="PageContainer_mainContent__2VeJN"><article><div class="PostView_postHeader__183v-"><h1>Terra</h1><span class="PostView_postDate__w6r5-">Feb 23, 2021</span></div><div class="PostView_postLinks__3B9dI"><a href="https://github.com/LucasPickering/terra-rs">Code</a><a href="https://terra.lucaspickering.me">Site</a></div><img loading="lazy" class="PostView_banner__HGY8M" data-src="http://res.cloudinary.com/lucaspickering/image/upload/f_auto,q_auto/v1/lucaspickering.me/terra/banner_xhecnx" style="opacity:0;position:absolute"/><div style="display:inline"><img loading="lazy" class="PostView_banner__HGY8M" data-src="http://res.cloudinary.com/lucaspickering/image/upload/f_auto,q_auto/e_blur:2000,f_auto,q_1/v1/lucaspickering.me/terra/banner_xhecnx"/></div><div><h2>Intro</h2><p>Terra is a 3D hexagon-based terrain generation library. It provides a highly configurable series of algorithms that can generate lifelike terrain. The core library itself doesn&#x27;t actually render the terrain, it just returns it in a format that makes rendering simple. It also includes a simple demo that renders the terrain in 3D, to see what it&#x27;s capable of (<a href="#demo">skip to the demo now</a>).</p><p>Shoutout to Amit Patel for <a href="https://www.redblobgames.com/grids/hexagons/">this post</a>, which has been an endless resource of information for working with hex grids.</p><h2>How does it work?</h2><p>The generator takes in a configuration object that contains a bunch of parameters that define the generation process. Chief among these is the <a href="https://en.wikipedia.org/wiki/Random_seed">random seed</a>. Beyond that, there are lots of different levers to control how different steps in the process behave. Based on the configuration, the generator applies a series of steps to initialize the world and create terrain.</p><p>If you&#x27;re curious, all the code for terrain generation <a href="https://github.com/LucasPickering/terra-rs/tree/master/crates/core/src/world/generate">lives here</a>.</p><h3>Step 0 - Initialize the world</h3><p>We start by initializing a world based on the defined world radius in the config. Each tile is initialized but doesn&#x27;t actually have any properties assigned yet. I haven&#x27;t included a picture for this step because there isn&#x27;t really anything to see yet.</p><h3>Step 1 - Generate elevation maps</h3><p>We start by defining an elevation for each tile, using a <a href="https://en.wikipedia.org/wiki/Perlin_noise">Perlin noise function</a>. Once again, credit to Amit Patel with <a href="https://www.redblobgames.com/maps/terrain-from-noise/">another great post</a> that explains noise-based terrain generation.</p><p>At this point, our terrain map looks something like this, where each tile has an elevation defined, but nothing else.</p><div class="Images_imagesWrapper__XfFcv"><div class="Images_images__2z67e"><img loading="lazy" data-src="http://res.cloudinary.com/lucaspickering/image/upload/f_auto,q_auto/v1/lucaspickering.me/terra/elevation_af9kpl" style="opacity:0;position:absolute"/><div style="display:inline"><img loading="lazy" data-src="http://res.cloudinary.com/lucaspickering/image/upload/f_auto,q_auto/e_blur:2000,f_auto,q_1/v1/lucaspickering.me/terra/elevation_af9kpl"/></div></div><div class="Images_caption__17yC0">The red tiles are the highest elevation while the white tiles are the lowest.</div></div><h3>Step 2 - Simulate rainfall</h3><p>Without going into too much detail, as this logic is subject to change, we simulate rainfall across the terrain. To do this, we first define where oceans will form based on which tiles are below sea level. Then, we pick a prevailing wind direction, which is uniform over the terrain. From there we can simulate evaporation (which occurs over bodies of water) and rainfall (which collects on tiles). This simulation is elevation-aware, meaning the spread of rainfall is affected by mountains. So land that is downwind of bodies of water gets the most rain, while land downwind of a mountain range won&#x27;t get very much rain at all.</p><p>At this point, each land tile will have some amount of rainfall assigned to it, which will be a function of its proximity to the ocean plus proximity to mountains and other elevation features. From here we can move onto the next step, which is simulating how that water flows and collects.</p><div class="Images_imagesWrapper__XfFcv"><div class="Images_images__2z67e"><img loading="lazy" data-src="http://res.cloudinary.com/lucaspickering/image/upload/f_auto,q_auto/v1/lucaspickering.me/terra/humidity_qliycy" style="opacity:0;position:absolute"/><div style="display:inline"><img loading="lazy" data-src="http://res.cloudinary.com/lucaspickering/image/upload/f_auto,q_auto/e_blur:2000,f_auto,q_1/v1/lucaspickering.me/terra/humidity_qliycy"/></div></div><div class="Images_caption__17yC0">The green tiles are the get the most rainfall while the white are the driest.</div></div><h3>Step 3 - Simulate runoff</h3><p>Runoff simulation is the process of simulating how water flows from one tile to the next, and where that runoff collects. The purpose of this step is to determine where rivers and lakes would naturally form on the terrain. The actual algorithms involved here are pretty complicated and subject to change so I won&#x27;t detail them too much, but the simplified version is this:</p><p>For each tile, we track two things:</p><ol><li>How much water collects on it</li><li>How much water flows over it, including where it flows from and where it flows to</li></ol><p>Once we have those, we can easily place lakes on tiles that collect a lot of water and rivers on tiles that have high water flow rates. When it&#x27;s all said and done, here&#x27;s what our map will look like:</p><div class="Images_imagesWrapper__XfFcv"><div class="Images_images__2z67e"><img loading="lazy" data-src="http://res.cloudinary.com/lucaspickering/image/upload/f_auto,q_auto/v1/lucaspickering.me/terra/runoff_cqbeg5" style="opacity:0;position:absolute"/><div style="display:inline"><img loading="lazy" data-src="http://res.cloudinary.com/lucaspickering/image/upload/f_auto,q_auto/e_blur:2000,f_auto,q_1/v1/lucaspickering.me/terra/runoff_cqbeg5"/></div></div><div class="Images_caption__17yC0">In this map, green represents runoff flow while blue is collected runoff. So the greenest tiles will become rivers, while the bluest will become lakes. Black tiles have little to no runoff flow over them, and gray tiles are ocean.</div></div><h3>Step 4 - Assign biomes</h3><p>Terra has a number of different biomes, which are assigned to tiles based on each tile&#x27;s individual elevation and humidity. By now we know what elevation is, but what is humidity? Humidity is derived from rainfall, meaning tiles that get the most rain are the most humid. Makes sense, right?</p><p>Because of the methodology we use to generation elevation and simulate rainfall, they both form in smooth gradients where each tile is going to have a pretty similar elevation &amp; humidity to the ones next to it. This means that biomes form in nice, natural-looking clusters.</p><p>So after all these steps, we end up with our final product!</p><div class="Images_imagesWrapper__XfFcv"><div class="Images_images__2z67e"><img loading="lazy" data-src="http://res.cloudinary.com/lucaspickering/image/upload/f_auto,q_auto/v1/lucaspickering.me/terra/final_w5m4zz" style="opacity:0;position:absolute"/><div style="display:inline"><img loading="lazy" data-src="http://res.cloudinary.com/lucaspickering/image/upload/f_auto,q_auto/e_blur:2000,f_auto,q_1/v1/lucaspickering.me/terra/final_w5m4zz"/></div></div><div class="Images_caption__17yC0">Tile color here represents biomes. The darkest green is jungle, the tan is plains, etc.</div></div><h2>So what are you gonna do with this?</h2><p>Right now this project exists on its own, meaning I&#x27;m not using it as part of any other projects. But given its modular and configurable design, I plan to use it as part of a few different game ideas that I have. Interesting terrain can be used in all kinds of different ways to make games feel varied and immersive. For now though, I&#x27;m just working on fleshing out this project.</p><p>TL;DR: You&#x27;ll have to wait and see.</p><h2>Can I use it?</h2><p>Please do! The crate isn&#x27;t published to <a href="https://crates.io">crates.io</a> (yet), but you can pull it in via the git URL, with something like this:</p><pre><code class="language-toml">terra = { git = &quot;https://github.com/LucasPickering/terra-rs&quot;, branch = &quot;master&quot; }
</code></pre><p>If do you start using this, please let me know what you think! Always open to suggestions, and if people are actually using this I can put it up on <code>crates.io</code> to make usage easier.</p><h2>Demo</h2><p>This demo is a simple TypeScript app that renders Terra terrain in 3D, entirely in the browser. This is accomplished by compiling Terra to <a href="https://webassembly.org/">WebAssembly</a>, then importing it from the TypeScript app. This is just a simple example of what you can do with Terra. The standalone version is available at <a href="https://terra.lucaspickering.me/">terra.lucaspickering.me</a>.</p></div></article></main><footer class="PageContainer_footer__2pitm"><span>Copyright 2021 Lucas Pickering</span><a href="/">Recursion!</a></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{}},"page":"/posts/terra","query":{},"buildId":"GOjKSWOk6q0aODtCvQMHr","nextExport":true,"autoExport":true,"isFallback":false,"scriptLoader":[]}</script></body></html>