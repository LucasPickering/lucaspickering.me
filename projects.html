<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>Lucas Pickering</title><meta name="theme-color" content="#383838"/><meta name="description" content="Me!"/><meta name="next-head-count" content="5"/><link rel="preload" href="/_next/static/css/5aa0192adee9681ad795.css" as="style"/><link rel="stylesheet" href="/_next/static/css/5aa0192adee9681ad795.css" data-n-g=""/><link rel="preload" href="/_next/static/css/21169aa5fdfff69e88e6.css" as="style"/><link rel="stylesheet" href="/_next/static/css/21169aa5fdfff69e88e6.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-a54b4f32bdc1ef890ddd.js"></script><script src="/_next/static/chunks/webpack-0e0f5c5c9fa5a29e0d78.js" defer=""></script><script src="/_next/static/chunks/framework-895f067827ebe11ffe45.js" defer=""></script><script src="/_next/static/chunks/main-b9780dc6f4fa7abb3771.js" defer=""></script><script src="/_next/static/chunks/pages/_app-19d88cb45a3a2e30a2e2.js" defer=""></script><script src="/_next/static/chunks/544-ee28b110819265c2926a.js" defer=""></script><script src="/_next/static/chunks/513-d2ad5a67844e54e116c9.js" defer=""></script><script src="/_next/static/chunks/pages/projects-8e6dbb7a88b52910b4d5.js" defer=""></script><script src="/_next/static/oRI836W5q4cO7FBqUl-D-/_buildManifest.js" defer=""></script><script src="/_next/static/oRI836W5q4cO7FBqUl-D-/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="PageContainer_contentWrapper__3Bc1C"><header class="NavHeader_navHeader__2wb8k"><nav class="NavHeader_navBar__1Dijy"><div class="NavHeader_titleLinkWrapper__3UzkA"><a class="NavHeader_titleLink__2BFBI" href="/">A Thought</a><p class="NavHeader_caption__2ehiM">(All I could muster)</p></div><div class="NavHeader_otherLinks__27YNZ"><a href="/projects/">Projects</a><a href="/photos/">Photos</a><a href="/about/">About Me</a><a href="https://github.com/LucasPickering">GitHub</a></div></nav></header><main class="PageContainer_mainContent__2VeJN"><h1>Nerd Projects</h1><div><div class="PostList_postTitleGroup__flIIZ"><h3 class="PostList_postTitle__116bN"><a href="/posts/laulud">Laulud</a></h3><span class="PostList_postDate__1phqD">Apr 6, 2021</span></div><img class="PostList_banner__2g4Xu" src="/assets/laulud/banner.png"/><p>Ever wanted to assign tags to tracks, albums, and artists in Spotify? No? Well I have because I&#x27;m neurotic. Laulud is a simple site to browse and tag Spotify items.</p></div><div><div class="PostList_postTitleGroup__flIIZ"><h3 class="PostList_postTitle__116bN"><a href="/posts/terra">Terra</a></h3><span class="PostList_postDate__1phqD">Feb 23, 2021</span></div><img class="PostList_banner__2g4Xu" src="/assets/terra/banner.png"/><p>A hexagon-tile terrain generation system. Dynamically generate and explore terrain. This is a generic toolkit that can be used to generate terrain for renderings, games, etc.</p></div><div><div class="PostList_postTitleGroup__flIIZ"><h3 class="PostList_postTitle__116bN"><a href="/posts/soze">Söze</a></h3><span class="PostList_postDate__1phqD">Nov 29, 2020</span></div><img class="PostList_banner__2g4Xu" src="/assets/soze/banner.png"/><p>Hardware mods for my PC, with a suite of software services to make it all run smoothly. The mods include an LCD mounted on the front and a strip of RGB LEDs inside, all driven by a Raspberry Pi Zero.</p></div></main><footer class="PageContainer_footer__2pitm"><span>Copyright 2021 Lucas Pickering</span><a href="/">Recursion!</a></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"metadata":{"title":"Laulud","date":"2021-04-06T00:00:00.000Z","summary":"Ever wanted to assign tags to tracks, albums, and artists in Spotify? No? Well I have because I'm neurotic. Laulud is a simple site to browse and tag Spotify items.","banner":"/assets/laulud/banner.png","links":{"Code":"https://github.com/LucasPickering/laulud","Site":"https://laulud.lucaspickering.me"},"tags":["post","project","rust","typescript","spotify"]},"slug":"laulud","markdown":"\n## What is it?\n\nLaulud is a simple site that lets you assign custom tags to tracks, albums, and artists from Spotify. Log in through Spotify, and all the tags will be attached to your Spotify account.\n\nThe site is pretty simple, not much more to explain about it. Click the link at the top of the post to try it out.\n\n## Is it safe? What data do you store?\n\nThe **only** user data that Laulud stores is your account ID, which is public anyway. When you log in, Spotify will tell you that the site is requesting more data than that (your name, username, profile picture, etc.). That is the _minimum_ amount of data we can request from Spotify, none of it other than the account ID ever gets used or stored.\n"},{"metadata":{"title":"Terra","date":"2021-02-23T00:00:00.000Z","summary":"A hexagon-tile terrain generation system. Dynamically generate and explore terrain. This is a generic toolkit that can be used to generate terrain for renderings, games, etc.","banner":"/assets/terra/banner.png","links":{"Code":"https://github.com/LucasPickering/terra-rs","Site":"https://terra.lucaspickering.me"},"tags":["post","project","rust","3d"]},"slug":"terra","markdown":"\n## Intro\n\nTerra is a 3D hexagon-based terrain generation library. It provides a highly configurable series of algorithms that can generate lifelike terrain. The core library itself doesn't actually render the terrain, it just returns it in a format that makes rendering simple. It also includes a simple demo that renders the terrain in 3D, to see what it's capable of ([skip to the demo now](#demo)).\n\nShoutout to Amit Patel for [this post](https://www.redblobgames.com/grids/hexagons/), which has been an endless resource of information for working with hex grids.\n\n## How does it work?\n\nThe generator takes in a configuration object that contains a bunch of parameters that define the generation process. Chief among these is the [random seed](https://en.wikipedia.org/wiki/Random_seed). Beyond that, there are lots of different levers to control how different steps in the process behave. Based on the configuration, the generator applies a series of steps to initialize the world and create terrain.\n\nIf you're curious, all the code for terrain generation [lives here](https://github.com/LucasPickering/terra-rs/tree/master/crates/core/src/world/generate).\n\n### Step 0 - Initialize the world\n\nWe start by initializing a world based on the defined world radius in the config. Each tile is initialized but doesn't actually have any properties assigned yet. I haven't included a picture for this step because there isn't really anything to see yet.\n\n### Step 1 - Generate elevation maps\n\nWe start by defining an elevation for each tile, using a [Perlin noise function](https://en.wikipedia.org/wiki/Perlin_noise). Once again, credit to Amit Patel with [another great post](https://www.redblobgames.com/maps/terrain-from-noise/) that explains noise-based terrain generation.\n\nAt this point, our terrain map looks something like this, where each tile has an elevation defined, but nothing else.\n\n![The red tiles are the highest elevation while the white tiles are the lowest.](/assets/terra/elevation.svg)\n\n### Step 2 - Simulate rainfall\n\nWithout going into too much detail, as this logic is subject to change, we simulate rainfall across the terrain. To do this, we first define where oceans will form based on which tiles are below sea level. Then, we pick a prevailing wind direction, which is uniform over the terrain. From there we can simulate evaporation (which occurs over bodies of water) and rainfall (which collects on tiles). This simulation is elevation-aware, meaning the spread of rainfall is affected by mountains. So land that is downwind of bodies of water gets the most rain, while land downwind of a mountain range won't get very much rain at all.\n\nAt this point, each land tile will have some amount of rainfall assigned to it, which will be a function of its proximity to the ocean plus proximity to mountains and other elevation features. From here we can move onto the next step, which is simulating how that water flows and collects.\n\n![The green tiles are the get the most rainfall while the white are the driest.](/assets/terra/humidity.svg)\n\n### Step 3 - Simulate runoff\n\nRunoff simulation is the process of simulating how water flows from one tile to the next, and where that runoff collects. The purpose of this step is to determine where rivers and lakes would naturally form on the terrain. The actual algorithms involved here are pretty complicated and subject to change so I won't detail them too much, but the simplified version is this:\n\nFor each tile, we track two things:\n\n1. How much water collects on it\n2. How much water flows over it, including where it flows from and where it flows to\n\nOnce we have those, we can easily place lakes on tiles that collect a lot of water and rivers on tiles that have high water flow rates. When it's all said and done, here's what our map will look like:\n\n![In this map, green represents runoff flow while blue is collected runoff. So the greenest tiles will become rivers, while the bluest will become lakes. Black tiles have little to no runoff flow over them, and gray tiles are ocean.](/assets/terra/runoff.svg)\n\n### Step 4 - Assign biomes\n\nTerra has a number of different biomes, which are assigned to tiles based on each tile's individual elevation and humidity. By now we know what elevation is, but what is humidity? Humidity is derived from rainfall, meaning tiles that get the most rain are the most humid. Makes sense, right?\n\nBecause of the methodology we use to generation elevation and simulate rainfall, they both form in smooth gradients where each tile is going to have a pretty similar elevation \u0026 humidity to the ones next to it. This means that biomes form in nice, natural-looking clusters.\n\nSo after all these steps, we end up with our final product!\n\n![Tile color here represents biomes. The darkest green is jungle, the tan is plains, etc.](/assets/terra/final.svg)\n\n## So what are you gonna do with this?\n\nRight now this project exists on its own, meaning I'm not using it as part of any other projects. But given its modular and configurable design, I plan to use it as part of a few different game ideas that I have. Interesting terrain can be used in all kinds of different ways to make games feel varied and immersive. For now though, I'm just working on fleshing out this project.\n\nTL;DR: You'll have to wait and see.\n\n## Can I use it?\n\nPlease do! The crate isn't published to [crates.io](https://crates.io) (yet), but you can pull it in via the git URL, with something like this:\n\n```toml\nterra = { git = \"https://github.com/LucasPickering/terra-rs\", branch = \"master\" }\n```\n\nIf do you start using this, please let me know what you think! Always open to suggestions, and if people are actually using this I can put it up on `crates.io` to make usage easier.\n\n## Demo\n\nThis demo is a simple TypeScript app that renders Terra terrain in 3D, entirely in the browser. This is accomplished by compiling Terra to [WebAssembly](https://webassembly.org/), then importing it from the TypeScript app. This is just a simple example of what you can do with Terra. The standalone version is available at [terra.lucaspickering.me](https://terra.lucaspickering.me/).\n"},{"metadata":{"title":"Söze","date":"2020-11-29T00:00:00.000Z","summary":"Hardware mods for my PC, with a suite of software services to make it all run smoothly. The mods include an LCD mounted on the front and a strip of RGB LEDs inside, all driven by a Raspberry Pi Zero.","banner":"/assets/soze/banner.png","links":{"Code":"https://github.com/LucasPickering/soze"},"tags":["post","project","python","typescript","hardware"]},"slug":"soze","markdown":"\n## Background\n\nA long time ago (circa 2013), I decided I wanted to mod my PC. Fortunately, my case (the [BitFenix Prodigy](https://www.bitfenix.com/products/chassis/mini-itx/prodigy/)) is very amenable to that kind of thing, so I had a lot of options. Over the years, I added stuff, took it away, changed it, turned it upside, and eventually ended up with what I have today: an RGB LED strip, and a character LCD mounted to the front.\n\n![The computer, in all its glory](/assets/soze/pc.jpg)\n\n## The Hardware\n\nThe hardware involved in this obviously includes the LEDs and an LCD, as well as a few other pieces that make it possible to control everything from software.\n\n### Raspberry Pi Zero\n\n[Raspberry Pi Zero W](https://www.raspberrypi.org/products/raspberry-pi-zero-w/) | [Adafruit motor HAT](https://www.adafruit.com/product/2348)\n\nThe RPi serves as the brains of the operation. It, along with the Motor HAT expansion board, controls the LEDs and the LCD. It also connects to the computer's power supply to determine when the PC turns on and off (which is used in the software to shift between \"day\" and \"night\" mode).\n\n![The Motor HAT on top with the Raspberry Pi visible underneath it](/assets/soze/rpi.jpg)\n\nThe RPi connects to the PC's motherboard via USB for power, and uses WiFi for network access. But since my PC case is basically a Faraday cage, sometimes the WiFi isn't strong enough and I have to fall back to using the USB as a network interface as well. Generally though, the WiFi is good enough. If you're curious, check out the README for [a detailed layout](https://github.com/LucasPickering/soze#pin-layout) of all the pins being used on the RPi.\n\n![The USB cable where it connects to the PC motherboard](/assets/soze/usb.jpg)\n\n### LEDs\n\n[RGB LED strip](https://www.adafruit.com/product/346)\n\nA simple RGB LED strip. Each component (red/green/blue) is controlled by PWM from a motor controller. This strip can display pretty much any color, but the catch is that the LEDs all show the same color at once. But still, RGB makes your computer faster (as proven by Science™), so this piece is critical. Similarly, I'm currently investigating the effects of flame decals on CPU performance. Early results are promising.\n\n![The LED strip routed around the top of the PC](/assets/soze/leds.jpg)\n\nThis LED strip has gone through a few iterations, including pure analog control (which involved a homemade heatsink to prevent the whole thing from catching fire) and being driven by an Arduino Uno. This current iteration, with the Raspberry Pi and the motor controller, is definitely the cleanest and most configurable of all though. Having a full blown OS in control means the software can be a lot more complex and can provide a web UI (see [UI](#ui)).\n\n### LCD\n\n[RGB backlight LCD](https://www.adafruit.com/product/498) | [LCD backpack](https://www.adafruit.com/product/781)\n\nThis is the more complicated half of the mods. I mounted a 20x4 character LCD onto the front of my PC (in the space intended for a 5.25\" CD drive). The LCD supports loading custom characters, which means I was able to define characters that form pieces of _bigger_ characters, which means... big numbers! Wow, computers!\n\n![The front of the LCD](/assets/soze/lcd_front.jpg)\n\nI initially drove this with an Arduino Uno wired directly to the LCD, but then I switched over to the Raspberry Pi and discovered Adafruit's LCD backpack, which cuts a 16-pin wiring operation down to a 3-pin UART connection. It also greatly simplifies the software logic to a basic serial protocol, which makes controlling screen content/color/etc. much easier.\n\n![The back side of the LCD (the larger green board) with the backpack (the smaller blue board)](/assets/soze/lcd_back.jpg)\n\n## The Software\n\nIf the RPi is the brain, then the software is the... braincode? I don't know, this metaphor is breaking down. Software do what software do, it tells the RPi how to function. Each of these four components is a separate body of code, and they all communicate with each other over the network. Here's a synopsis of all the pieces. Basically, the UI talks to the API over HTTP (like and normal web app), then within the server, everything uses Redis as an intermediary.\n\n![A diagram of the software components](/assets/soze/diagram.png)\n\nRedis is great for this application because it's fast, lightweight, handles all the annoying parts of networking, and the pub/sub model makes it easy to notify the other components when something changes. It also provides some basic persistence, which is easier to use than dumping settings to a JSON file and reloading them on startup.\n\n### UI\n\nEveryone loves web development, right? This is a pretty simple UI built in TypeScript with React. It gives you full control of the LEDs and the LCD. It's hosted directly of the RPi, which makes deployment easy, but unfortunately means it's only accessible on the LAN. To make it accessible anywhere on the Internet, I'd have to set up a VPN to the RPi, host the UI elsewhere, and figure out auth. That sounds like a lot of work, and why would I want to control the PC while I'm not home anyway?\n\n![The Söze web UI](/assets/soze/ui.png)\n\n### API\n\nThis is a pretty thin layer that provides read/write access to the user's settings via HTTP. It uses Python+Flask. It doesn't involve any auth/permissions/etc., so very simple. For reads, this just reads a JSON string from Redis and returns it to the user. For writes, it basically validates JSON then dumps it into Redis.\n\n### Reducer\n\nSo if the RPi is the brain and the software is the braincode, then the reducer is the brain's Supreme Metatarsal Cortex (or something like that). Basically, this is the chunk of the code that takes the users settings and constantly calculates what each bit of hardware should be doing. Periodically (e.g. every 10ms), it recalculates the current LED color, and the current LCD text and color, then sends that data to the display.\n\nThis communicates in both directions via Redis. It reads user settings from Redis, calculates derived state, then writes that back to different keys in Redis.\n\nThe whole system is designed in order to offload all the difficult logic into the reducer. By putting all the complicated stuff in one place, it makes it easy to add and change functionality. And in most cases, changes here require minimal to no corresponding changes in the API/display, because the Redis contracts are decided to be as unrestrictive as possible.\n\n### Display\n\nThe display is a minimal adapter between the reducer and the actual hardware. The reducer produces an RGB color for the LEDs and a stream of binary commands for the LCD, so all the display has to do is take that data from Redis and forward out over the appropriate hardware channels. It might seem like this job doesn't justify having a completely separate service, but there's a big upside to it: mocking.\n\nWhen developing and running this on my desktop/laptop, obviously the expected hardware isn't present. After experimenting with a few other mocking mechanisms at first, I found this was the easiest way to do mocking. There is an alternative display that doesn't attempt to interact with hardware at all, and instead just mimics the LED and LCD state in a terminal window. This makes it easy to spin up 90% of the stack exactly how it would exist on the RPi, and minimize the amount of code that has to be mocked.\n\n## In Conclusion\n\nSo that's like... everything. Hope it was interesting? All the code is [on GitHub](https://github.com/LucasPickering/soze) (the hardware is not). It's taken many years of tweaking but I'm very happy with where this setup is now. I'm sure I'll continue to work on it in the future (currently I'm working on porting chunks of the software to Rust for fun), so it's only going to get better.\n"}],"_superjson":{"values":{"posts.0.metadata.date":["Date"],"posts.1.metadata.date":["Date"],"posts.2.metadata.date":["Date"]}}},"__N_SSG":true},"page":"/projects","query":{},"buildId":"oRI836W5q4cO7FBqUl-D-","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>